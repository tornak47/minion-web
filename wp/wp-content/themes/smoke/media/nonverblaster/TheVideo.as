package nonverblaster {	import flash.display.*;	import flash.events.*;	import flash.media.*;	import flash.net.*;	import flash.external.*;		public class TheVideo extends MovieClip{				public var connection			:NetConnection;		public var stream				:NetStream;		private var main				:MovieClip;		private var urlReq				:URLRequest;				private var overlay				:Sprite = new Sprite();				private var bt					:Number = 1;		public var videoURL			:String;		private var allowSmoothing		:Boolean = true;				public var indentImage			:IndentImage;		public var video				:Video;				//		// Object to save the metadata of the video in		public var meta:Object;				public function TheVideo($main){			this.main = $main;			this.addChild(overlay);			visible = false;			video = new Video();			addChild(video);		}		public function close(){			try {				connection.close();			} catch(e:Error){};			try {				stream.close();			} catch(e:Error){};		}		public function init($bt, $allowSmoothing, $videoURL){			close();						trace("video init!");						bt = $bt;			allowSmoothing = $allowSmoothing;			videoURL = $videoURL;						// Initialize the video object and attach the NetStream						if(Glo.bal.onClick != "" && Glo.bal.onClick != "disabled"){				overlay.buttonMode = true;				overlay.addEventListener(MouseEvent.CLICK, btHandler);			}			this.mouseEnabled = false;			overlay.contextMenu = Glo.bal.customContextMenu;						createConnection();			indentImage = new IndentImage();			this.addChild(indentImage);		}		public function createConnection(){			connection = new NetConnection();			connection.client = this;			connection.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);            connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			connection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);						connection.connect(null);		}		private function connectStream(){						stream = new NetStream(connection);			stream.bufferTime = bt;						video.smoothing = true;			video.x = 0;			video.y = 0;			video.attachNetStream(stream);									var nsClient = new Object();			nsClient.onMetaData = metaDataHandler;			stream.client = nsClient;			stream.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); 			stream.addEventListener(NetStatusEvent.NET_STATUS, netStatusHandler);		}		public function playVideo(){			stream.play(videoURL);			stream.seek(0);			//trace("play Video: " + videoURL);			video.visible = true;		}		public function restart(){			stream.seek(0);			stream.resume();			video.visible = true;		}		public function togglePlay(){			stream.togglePause();		}		public function setDefault(){			try {				stream.play(videoURL);				stream.seek(0);				stream.pause();			} catch(e:Error){};		}		public function resume(){			stream.resume();		}		public function setPause(){			stream.pause();		}		//		// As soon as the netStream gets the metadata from the video file...		//		public function metaDataHandler(metadataObj:Object):void {			// save the metadata			meta = metadataObj;						video.width = meta.width;			video.height = meta.height;			// set the width and height of the video as described in the metadata object						drawOverlay();						//			// position the elements			main.fitToScreen(null);		}		private function drawOverlay(){			var g = overlay.graphics;			g.clear();			g.beginFill(0xff0000, 0);			g.drawRect(0,0, meta.width, meta.height);			g.endFill();					}		private function btHandler(event:Event){			switch(event.type){				case "click":				if(Glo.bal.onClick == "togglePlay"){					main.togglePlay();				} else if(Glo.bal.onClick == "toggleFullScreen"){					main.toggleFullScreen();				} else if(Glo.bal.onClick.indexOf(".") != -1) {					navigateToURL(new URLRequest(Glo.bal.onClick), "_self");				}				break;			}		}		//		// Controlling Methods		//		public function getTotalTime():Number{			return meta.duration;		}		public function getPlayingProgress():Number{			return(stream.time / meta.duration);		}		public function getLoadingProgress():Number {			return(stream.bytesLoaded / stream.bytesTotal);		}		public function getTime():Number {			return(stream.time);		}		public function getDuration():Number {			return(meta.duration);		}		public function setPlayingProgress(progressBarScale):void {			stream.seek(progressBarScale * meta.duration);		}		public function setSoundTransform(st){			stream.soundTransform = st;		}		public function getVolume():Number{			return(stream.soundTransform.volume);		}				//////////////////////////////////////////////////////////////////////		// NetStream Listener		private function netStatusHandler(event:NetStatusEvent):void {			try {				switch (event.info.code) {					case "NetConnection.Connect.Success":					connectStream();					break;										case "NetStream.Play.StreamNotFound":					main.showError("No video file was found! \n" + videoURL);					main.bufferWheel.fadeOut();					trace("Stream not found!");					break;										case "NetStream.Play.Start" :					break;										case "NetStream.Buffer.Full" :											break;										case "NetStream.Buffer.Empty" :					if(main.isPlaying == true){						main.bufferWheel.fadeIn();					}					break;										case "NetStream.Play.Stop" :					if(main.isSeeking != true){						main.setEnd();					}					break;				}			} catch (error:TypeError) {}		}		////////////////////////////////////////////////////////////////////////////////		// All Handlers Flash needs, omg :(		//		private function asyncErrorHandler(e:AsyncErrorEvent){			trace("Async Error! " + e.target);		}		public function onBWDone(){			//trace("onBWDoneHandler");		}        private function securityErrorHandler(event:SecurityErrorEvent):void {                   }	}	}